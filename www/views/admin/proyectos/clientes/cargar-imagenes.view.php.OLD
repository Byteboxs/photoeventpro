<!-- <style>
    #drop-area {
        border: 2px dashed #ccc;
        border-radius: 20px;
        width: 100%;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        cursor: pointer;
    }

    #drop-area.highlight {
        border-color: #007bff;
    }

    #image-preview {
        display: flex;
        /* O display: inline-block; si prefieres esa opción */
        flex-wrap: wrap;
        /* Opcional: para que las imágenes se ajusten a varias líneas */
    }

    #image-preview img {
        margin: 5px;
        /* Espacio entre las imágenes */
    }
</style> -->
<style>
    #drop-area {
        border: 2px dashed #ccc;
        border-radius: 20px;
        width: 100%;
        height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        cursor: pointer;
    }

    #drop-area.highlight {
        border-color: #007bff;
    }

    #image-preview {
        display: flex;
        flex-wrap: wrap;
        /* Añadido min-height para asegurar que el contenedor sea visible incluso si está vacío inicialmente */
        min-height: 50px;
        /* Ajusta este valor si es necesario */
        border: 1px solid rgba(0, 0, 0, .125);
        /* Opcional: Para que veas el borde del contenedor de previsualización */
        padding: 10px;
        /* Opcional: Para dar un poco de espacio interno */
        border-radius: 0.25rem;
        /* Opcional: Bordes redondeados si lo deseas */
        margin-top: 10px;
        /* Opcional: Margen superior para separarlo del drop-area */
    }

    #image-preview img {
        margin: 5px;
        max-width: 100px;
        /* Ajusta este valor máximo si es necesario */
        height: auto;
        /* Para mantener la proporción de aspecto */
        display: block;
        /* Asegura que no haya problemas de espaciado en flexbox */
    }

    .preview-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        /* Centrar texto debajo de la imagen */
    }

    .delete-btn {
        margin-top: 5px;
        /* Separación del botón de borrar de la imagen */
    }

    .loading-indicator {
        font-size: 0.8em;
        color: grey;
        margin-top: 5px;
    }

    .file-name {
        margin-top: 5px;
    }
</style>
<!-- <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-6 row-gap-4">

    <div class="d-flex flex-column justify-content-center">
        <p class="mb-0"></p>
    </div>
    <div class="d-flex align-content-center flex-wrap gap-4">
    </div>
</div>

<form id="image-upload-form" class="card shadow-none border border-primary overflow-hidden" enctype="multipart/form-data">
    <div class="card-body">
        <h1>Cargar Imágenes</h1>
        <input type="hidden" id="proyecto_id" name="proyecto_id" value="1">
        <input type="hidden" id="cliente_id" name="cliente_id" value="1">

        <div id="drop-area">
            <p>Arrastra y suelta imágenes aquí o haz clic para seleccionar</p>
            <input type="file" id="images" name="images[]" multiple accept="image/*" style="display: none;">
        </div>
        <div id="image-preview"></div>
        <div id="upload-progress" class="progress" style="display:none;">
            <div class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
        <div id="upload-message"></div>
        <div id="form-responses" class="mt-3"></div>
    </div>
    <div class="card-footer">
        <button type="submit" class="btn btn-primary">
            <i class="fas fa-upload mx-1"></i> Subir Imágenes y Datos
        </button>
    </div>
</form> -->
<div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-6 row-gap-4">

    <div class="d-flex flex-column justify-content-center">
        <p class="mb-0"></p>
    </div>
    <div class="d-flex align-content-center flex-wrap gap-4">
    </div>
</div>

<form id="image-upload-form" class="card shadow-none border border-primary overflow-hidden" enctype="multipart/form-data">
    <div class="card-body">
        <h1>Cargar Imágenes</h1>
        <input type="hidden" id="proyecto_id" name="proyecto_id" value="1">
        <input type="hidden" id="cliente_id" name="cliente_id" value="1">

        <div id="drop-area">
            <p>Arrastra y suelta imágenes aquí o haz clic para seleccionar</p>
            <input type="file" id="images" name="images[]" multiple accept="image/*" style="display: none;">
        </div>
        <div id="image-preview"></div>
        <div id="upload-progress" class="progress" style="display:none;">
            <div class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
        <div id="upload-message"></div>
        <div id="form-responses" class="mt-3"></div>
    </div>
    <div class="card-footer">
        <button type="submit" class="btn btn-primary">
            <i class="fas fa-upload mx-1"></i> Subir Imágenes y Datos
        </button>
    </div>
</form>
<script>
    /**
     * Clase ImageCompressor: Responsable de la compresión de imágenes y orientación.
     */
    class ImageCompressor {
        constructor(defaultQuality = 0.7, defaultMaxWidth = 800) {
            this.defaultQuality = defaultQuality;
            this.defaultMaxWidth = defaultMaxWidth;
            console.log("ImageCompressor: Constructor inicializado con calidad:", defaultQuality, "y maxWidth:", defaultMaxWidth); // LOG Constructor
        }

        /**
         * Comprime un archivo de imagen y aplica corrección de orientación si es horizontal.
         * @param {File} imageFile - El archivo de imagen a comprimir.
         * @param {object} options - Opciones de compresión (quality, maxWidth).
         * @returns {Promise<Blob|null>} - Promesa que resuelve con el Blob comprimido o null en caso de error.
         */
        compress(imageFile, options = {}) {
            console.log("ImageCompressor: compress() llamado para", imageFile.name); // LOG Inicio compress
            return new Promise((resolve, reject) => {
                console.log("ImageCompressor: Iniciando compresión para", imageFile.name);
                const quality = options.quality !== undefined ? options.quality : this.defaultQuality;
                const maxWidth = options.maxWidth !== undefined ? options.maxWidth : this.defaultMaxWidth;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = async () => { // Cambiado a async para usar await en rotateImage si es necesario
                        let width = img.width;
                        let height = img.height;

                        // Detectar orientación horizontal y rotar si es necesario
                        console.log("ImageCompressor: Dimensiones iniciales:", {
                            width,
                            height
                        }); // AÑADIDO LOG Dimensiones iniciales
                        if (this.isImageHorizontal(width, height)) {
                            console.log("ImageCompressor: Imagen horizontal detectada, rotando.");
                            const rotatedCanvas = await this.rotateImage(img); // Esperar a que la rotación termine
                            console.log("ImageCompressor: Rotación completada."); // LOG Rotación completada
                            width = rotatedCanvas.width;
                            height = rotatedCanvas.height;
                            img.src = rotatedCanvas.toDataURL('image/jpeg', 1); // Actualizar la fuente de la imagen con la rotada
                        }

                        const canvas = document.createElement('canvas');
                        if (maxWidth && width > maxWidth) {
                            height = (maxWidth / width) * height;
                            width = maxWidth;
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        console.log("ImageCompressor: Iniciando canvas.toBlob con calidad:", quality); // LOG canvas.toBlob inicio
                        canvas.toBlob(blob => {
                            if (blob) {
                                console.log("ImageCompressor: Compresión exitosa para", imageFile.name, "Tamaño comprimido:", blob.size);
                                resolve(blob);
                            } else {
                                console.error("ImageCompressor: Fallo al comprimir con canvas.toBlob para", imageFile.name);
                                reject(new Error("Canvas toBlob falló."));
                                resolve(null);
                            }
                        }, 'image/jpeg', quality); // LOG canvas.toBlob fin, calidad usada
                    };
                    img.onerror = () => {
                        console.error("ImageCompressor: Error al cargar imagen", imageFile.name);
                        reject(new Error("Error al cargar la imagen."));
                        resolve(null);
                    };
                };
                reader.onerror = () => {
                    console.error("ImageCompressor: Error FileReader al leer", imageFile.name);
                    reject(new Error("FileReader error."));
                    resolve(null);
                };
                reader.readAsDataURL(imageFile);
            });
        }

        /**
         * Detecta si una imagen tiene orientación horizontal basada en su relación de aspecto.
         * @param {number} width - Ancho de la imagen.
         * @param {number} height - Alto de la imagen.
         * @returns {boolean} - True si la imagen es horizontal, false si no.
         */
        isImageHorizontal(width, height) {
            console.log("ImageCompressor: isImageHorizontal() llamado con ancho:", width, "y alto:", height); // LOG isImageHorizontal
            return width > height;
        }

        /**
         * Rota una imagen 90 grados a la derecha utilizando un canvas.
         * @param {HTMLImageElement} image - Objeto imagen a rotar.
         * @returns {Promise<HTMLCanvasElement>} - Promesa que resuelve con el canvas de la imagen rotada.
         */
        rotateImage(image) {
            console.log("ImageCompressor: rotateImage() llamado"); // LOG rotateImage inicio
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                // Invertir ancho y alto para la rotación de 90 grados
                canvas.width = image.height;
                canvas.height = image.width;

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar el canvas

                // Trasladar el contexto para que el punto de origen (0,0) esté en el centro
                ctx.translate(canvas.width / 2, canvas.height / 2);

                // Rotar 90 grados (en radianes)
                ctx.rotate(90 * Math.PI / 180);

                // Dibujar la imagen rotada (invertir coordenadas debido a la rotación)
                ctx.drawImage(image, -image.height / 2, -image.width / 2, image.width, image.height);

                console.log("ImageCompressor: rotateImage() promesa resolve."); // LOG rotateImage fin promesa
                resolve(canvas);
            });
        }
    }

    /**
     * Clase FileUploader: Responsable de subir archivos al servidor.
     */
    class FileUploader {
        /**
         * Sube datos de formulario al servidor.
         * @param {FormData} formData - Datos del formulario a subir.
         * @param {string} uploadUrl - URL del endpoint de subida.
         * @param {function} progressCallback - Callback para el progreso de subida (opcional).
         * @param {function} responseCallback - Callback para manejar la respuesta exitosa del servidor.
         * @param {function} errorCallback - Callback para manejar errores de subida.
         */
        upload(formData, uploadUrl, progressCallback, responseCallback, errorCallback) {
            console.log("FileUploader: upload() llamado a URL:", uploadUrl); // LOG FileUploader upload inicio
            console.log("FileUploader: Iniciando subida a", uploadUrl);
            fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                })
                .then(response => {
                    console.log("FileUploader: Respuesta recibida, estado:", response.status);
                    if (!response.ok) {
                        console.error("FileUploader: Error en respuesta HTTP:", response.status);
                        return response.text().then(text => {
                            throw new Error(`Error HTTP ${response.status}: ${text}`);
                        });
                    }
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return response.json();
                    } else if (contentType && contentType.includes('text/html')) {
                        return response.text();
                    } else if (contentType && contentType.includes('text/plain')) {
                        return response.text();
                    } else {
                        return response.text();
                    }
                })
                .then(data => {
                    console.log("FileUploader: Subida exitosa, datos de respuesta:", data);
                    responseCallback(data);
                })
                .catch(error => {
                    console.error("FileUploader: Error durante la subida:", error);
                    errorCallback(error);
                });
        }
    }

    /**
     * Clase UIController: Responsable de gestionar la interacción con la interfaz de usuario.
     */
    class UIController {
        constructor(dropAreaId, inputFileId, previewId, progressId, progressBarSelector, uploadMessageId, formResponsesId) {
            console.log("UIController: Constructor inicializado."); // LOG UIController constructor
            this.dropArea = document.getElementById(dropAreaId);
            this.inputFile = document.getElementById(inputFileId);
            this.preview = document.getElementById(previewId);
            this.progress = document.getElementById(progressId);
            this.progressBar = this.progress.querySelector(progressBarSelector);
            this.uploadMessage = document.getElementById(uploadMessageId);
            this.formResponsesDiv = document.getElementById(formResponsesId);

            // Deshabilitar el botón de submit inicialmente
            this.disableSubmitButton();
        }

        initializeDropArea(handleDropCallback) {
            console.log("UIController: initializeDropArea() llamado."); // LOG initializeDropArea
            const dropArea = this.dropArea;
            const highlight = () => dropArea.classList.add('highlight');
            const unhighlight = () => dropArea.classList.remove('highlight');
            const preventDefaults = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            dropArea.addEventListener('drop', (e) => {
                unhighlight(e);
                handleDropCallback(e.dataTransfer.files);
            }, false);
        }

        initializeInputFileClick(handleClickCallback) {
            console.log("UIController: initializeInputFileClick() llamado."); // LOG initializeInputFileClick
            this.dropArea.addEventListener('click', () => {
                handleClickCallback();
                this.inputFile.click();
            });
        }

        initializeInputFileChange(handleChangeCallback) {
            console.log("UIController: initializeInputFileChange() llamado."); // LOG initializeInputFileChange
            this.inputFile.addEventListener('change', () => {
                handleChangeCallback(this.inputFile.files);
            });
        }

        // MODIFICACIÓN: previewFile ahora crea botón de eliminar
        previewFile(file, previewArea, fileName, fileIndex, deleteCallback) { // Añadido fileIndex y deleteCallback
            console.log("UIController: previewFile() llamado para archivo:", fileName || 'Blob'); // LOG previewFile
            console.log("UIController: previewFile llamado para archivo:", fileName || 'Blob');

            // Contenedor para la miniatura, nombre del archivo e indicador de carga
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item'; // Puedes añadir estilos CSS para esto
            previewItem.dataset.index = fileIndex; // Añadir índice como data attribute

            // Imagen miniatura
            const img = document.createElement('img');
            img.classList.add('img-thumbnail', 'm-2');
            img.style.maxWidth = '100px';

            // Nombre del archivo debajo de la miniatura
            const fileNamePara = document.createElement('p');
            fileNamePara.textContent = fileName || 'Imagen';
            fileNamePara.className = 'file-name'; // Clase para estilizar si es necesario
            fileNamePara.style.wordWrap = 'break-word'; // Permite romper palabras largas
            fileNamePara.style.maxWidth = '100px';
            fileNamePara.style.fontSize = '0.8em';
            fileNamePara.style.textAlign = 'center';

            // Indicador de carga (spinner - puedes personalizarlo con CSS)
            const loadingIndicator = document.createElement('span');
            loadingIndicator.className = 'loading-indicator'; // Clase para CSS del spinner
            loadingIndicator.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Cargando...'; // Ejemplo con FontAwesome, texto

            // MODIFICACIÓN: Botón de eliminar
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '<i class="far fa-trash-alt"></i>';
            deleteButton.className = 'btn btn-danger btn-sm delete-btn'; // Clases Bootstrap y clase personalizada
            deleteButton.style.marginLeft = '5px'; // Espacio entre imagen y botón
            deleteButton.addEventListener('click', (event) => {
                event.preventDefault(); // Evitar que el botón dentro del formulario haga submit
                deleteCallback(fileIndex); // Llamar al callback de eliminación con el índice
            });


            previewItem.appendChild(img);
            previewItem.appendChild(fileNamePara);
            previewItem.appendChild(loadingIndicator);
            previewItem.appendChild(deleteButton); // Añadir botón de eliminar
            previewArea.appendChild(previewItem);


            let reader = new FileReader();
            reader.onloadend = () => {
                img.src = reader.result;
                loadingIndicator.style.display = 'none'; // Ocultar el indicador cuando la imagen carga
                console.log("UIController: Vista previa de imagen añadida para:", fileName || 'Blob');
            };
            reader.readAsDataURL(file);
        }

        previewFiles(files, previewFileCallback, deleteCallback) { // MODIFICACIÓN: Añadido deleteCallback
            console.log("UIController: previewFiles() llamado para", files.length, "archivos."); // LOG previewFiles
            // MODIFICACIÓN: No limpiar preview.innerHTML aquí para permitir adición acumulativa.
            // this.preview.innerHTML = '';
            for (let i = 0; i < files.length; i++) {
                // MODIFICACIÓN: Pasar el nombre del archivo, índice y deleteCallback a previewFileCallback
                previewFileCallback(files[i], this.preview, files[i].originalName, i, deleteCallback);
            }
        }

        displayUploadProgress(percent) {
            console.log("UIController: displayUploadProgress() llamado con porcentaje:", percent); // LOG displayUploadProgress
            this.progress.style.display = 'block';
            this.progressBar.style.width = percent + '%';
            this.progressBar.innerHTML = percent + '%';
        }

        hideUploadProgress() {
            console.log("UIController: hideUploadProgress() llamado."); // LOG hideUploadProgress
            this.progress.style.display = 'none';
            this.progressBar.style.width = '0%';
            this.progressBar.innerHTML = '0%';
        }

        displayUploadMessage(message, type = 'success') {
            console.log("UIController: displayUploadMessage() llamado con mensaje:", message, "y tipo:", type); // LOG displayUploadMessage
            this.uploadMessage.innerHTML += `<div class='alert alert-${type} mt-2'>${message}</div>`;
        }

        clearUploadMessages() {
            console.log("UIController: clearUploadMessages() llamado."); // LOG clearUploadMessages
            this.uploadMessage.innerHTML = '';
        }

        displayFormResponses(data) {
            console.log("UIController: displayFormResponses() llamado con datos:", data); // LOG displayFormResponses
            this.formResponsesDiv.innerHTML = '';
            if (typeof data === 'object' && data !== null) {
                console.log("UIController: Respuesta JSON del servidor:", data);
                // let responseText = JSON.stringify(data, null, 2);
                // const pre = document.createElement('pre');
                // pre.textContent = responseText;
                // this.formResponsesDiv.appendChild(pre);
                if (data.status === "success") {
                    let responseDiv = document.getElementById("form-responses");
                    responseDiv.innerHTML = '';
                    const alert = BootstrapAlertFactory.createAlert({
                        message: data.message || 'Ocurrió un error en la petición.',
                        type: 'success',
                        dismissible: true,
                        icon: "far fa-check-circle",
                    });
                    this.formResponsesDiv.appendChild(alert.generateAlert());
                } else if (data.status === "fail") {
                    let responseDiv = document.getElementById("form-responses");
                    responseDiv.innerHTML = '';
                    const alert = BootstrapAlertFactory.createAlert({
                        message: data.message || 'Ocurrió un error en la petición.',
                        type: 'danger',
                        dismissible: true,
                        icon: "far fa-times-circle",
                    });
                    this.formResponsesDiv.appendChild(alert.generateAlert());
                } else if (data.status === "warning") {
                    let responseDiv = document.getElementById("form-responses");
                    responseDiv.innerHTML = '';
                    const alert = BootstrapAlertFactory.createAlert({
                        message: data.message || 'Ocurrió un error en la petición.',
                        type: 'warning',
                        dismissible: true,
                        icon: "fas fa-exclamation-triangle",
                    });
                    this.formResponsesDiv.appendChild(alert.generateAlert());
                }

            } else if (typeof data === 'string') {
                this.formResponsesDiv.innerHTML = data;
            }
        }

        clearPreviewArea() {
            console.log("UIController: clearPreviewArea() llamado."); // LOG clearPreviewArea
            this.preview.innerHTML = '';
        }

        resetForm() {
            console.log("UIController: resetForm() llamado."); // LOG resetForm
            document.getElementById('image-upload-form').reset();
        }

        disableSubmitButton() {
            console.log("UIController: disableSubmitButton() llamado."); // LOG disableSubmitButton
            const botonEnviar = document.querySelector('#image-upload-form button[type="submit"]');
            if (botonEnviar) botonEnviar.disabled = true;
        }

        enableSubmitButton() {
            console.log("UIController: enableSubmitButton() llamado."); // LOG enableSubmitButton
            const botonEnviar = document.querySelector('#image-upload-form button[type="submit"]');
            if (botonEnviar) botonEnviar.disabled = false;
        }

        // MODIFICACIÓN: Método para eliminar una vista previa individualmente por índice
        removePreviewItem(index) {
            console.log("UIController: removePreviewItem() llamado con índice:", index); // LOG removePreviewItem
            const previewItemToRemove = this.preview.querySelector(`.preview-item[data-index="${index}"]`);
            if (previewItemToRemove) {
                this.preview.removeChild(previewItemToRemove);
            }
        }
    }


    /**
     * Clase ImageUploadController: Orquesta la carga de imágenes, compresión y subida.
     */
    class ImageUploadController {
        constructor(compressor, uploader, uiController, uploadUrl) {
            console.log("ImageUploadController: Constructor inicializado."); // LOG ImageUploadController constructor
            this.compressor = compressor;
            this.uploader = uploader;
            this.uiController = uiController;
            this.uploadUrl = uploadUrl;
            this.filesToUpload = [];
            this.isUploading = false; // Nueva variable para rastrear el estado de subida
        }

        initialize() {
            console.log("ImageUploadController: initialize() llamado."); // LOG ImageUploadController initialize
            this.uiController.initializeDropArea(this.handleDrop.bind(this));
            this.uiController.initializeInputFileClick(this.handleDropAreaClick.bind(this));
            this.uiController.initializeInputFileChange(this.handleInputChange.bind(this));
            document.getElementById('image-upload-form').addEventListener('submit', this.handleSubmit.bind(this));
        }


        handleDrop(files) {
            console.log("ImageUploadController: handleDrop() llamado", files); // LOG handleDrop
            this.processFiles(files);
        }

        handleInputChange(files) {
            console.log("ImageUploadController: handleInputChange() llamado", files); // LOG handleInputChange
            this.processFiles(files);
        }

        handleDropAreaClick() {
            console.log("ImageUploadController: handleDropAreaClick() llamado"); // LOG handleDropAreaClick
        }


        processFiles(files) {
            console.log("ImageUploadController: processFiles() llamado con", files.length, "archivos."); // LOG processFiles
            // MODIFICACIÓN: No limpiar this.filesToUpload ni preview.innerHTML para adición acumulativa
            // this.filesToUpload = [];
            // this.uiController.clearPreviewArea();

            if (!files || files.length === 0) {
                console.log("ImageUploadController: No se seleccionaron archivos.");
                if (this.filesToUpload.length === 0) {
                    this.uiController.disableSubmitButton(); // Deshabilitar si no hay archivos seleccionados
                }
                return;
            }

            const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
            if (validFiles.length !== files.length) {
                console.warn("ImageUploadController: Algunos archivos no son imágenes y fueron omitidos.");
                this.uiController.displayUploadMessage('Algunos archivos no son imágenes y fueron omitidos.', 'warning');
            }

            const previewFiles = []; // Array para almacenar los blobs para la vista previa.
            let fileIndex = this.filesToUpload.length; // Índice para rastrear los archivos en filesToUpload

            if (validFiles.length > 0 || this.filesToUpload.length > 0) {
                this.uiController.enableSubmitButton(); // Habilitar si hay archivos válidos o ya existen archivos
            } else {
                this.uiController.disableSubmitButton(); // Deshabilitar si no hay archivos válidos y no existen archivos previos
            }

            // Iterar sobre los archivos válidos e iniciar la compresión y la vista previa
            validFiles.forEach(file => {
                // Mostrar la vista previa inicial con indicador de carga y nombre de archivo
                // MODIFICACIÓN: Pasar el índice y el callback de eliminación a previewFile
                this.uiController.previewFile(file, this.uiController.preview, file.name, fileIndex, this.deletePreviewFile.bind(this)); // Mostrar vista previa INICIAL con indicador y botón de eliminar

                this.compressor.compress(file, {}).then(compressedBlob => {
                    if (compressedBlob) {
                        // MODIFICACIÓN: Guardar el índice en filesToUpload para referenciarlo al eliminar
                        this.filesToUpload.push({
                            blob: compressedBlob,
                            originalName: file.name,
                            index: fileIndex
                        });
                        previewFiles.push(compressedBlob); // Añadir Blob comprimido para vista previa
                        // La vista previa de la imagen final se actualiza automáticamente en previewFile del UIController al cargar el blob
                    } else {
                        this.uiController.displayUploadMessage(`Error al comprimir la imagen: ${file.name}`, 'danger');
                    }
                }).catch(error => {
                    this.uiController.displayUploadMessage(`Error durante la compresión de ${file.name}: ${error.message}`, 'danger');
                });
                fileIndex++; // Incrementar el índice para el siguiente archivo
            });
            // No necesitamos llamar a `this.uiController.previewFiles(previewFiles, this.previewFile);` aquí
            // porque ahora la vista previa se maneja individualmente dentro del bucle anterior al llamar a `this.uiController.previewFile`
        }


        previewFile(file, previewArea) {
            // Esta función previewFile en ImageUploadController ya no es directamente utilizada
            // La lógica de vista previa ahora se delega completamente a UIController.previewFile
            // y se llama individualmente en processFiles para cada archivo.
        }

        // MODIFICACIÓN: Función para eliminar archivo de la vista previa y filesToUpload
        deletePreviewFile(indexToDelete) {
            console.log("ImageUploadController: deletePreviewFile() llamado con índice:", indexToDelete); // LOG deletePreviewFile
            // 1. Eliminar el elemento de vista previa del DOM usando UIController
            this.uiController.removePreviewItem(indexToDelete);

            // 2. Filtrar filesToUpload para remover el archivo con el índice correspondiente
            this.filesToUpload = this.filesToUpload.filter(fileData => fileData.index !== indexToDelete);

            console.log("ImageUploadController: Archivo con índice", indexToDelete, "eliminado.");

            if (this.filesToUpload.length === 0) {
                this.uiController.disableSubmitButton(); // Deshabilitar si no quedan archivos
            } else {
                this.uiController.enableSubmitButton(); // Habilitar si aún quedan archivos
            }
        }


        handleSubmit(e) {
            console.log("ImageUploadController: handleSubmit() llamado."); // LOG handleSubmit
            e.preventDefault();
            this.uploadFormData();
        }


        uploadFormData() {
            console.log("ImageUploadController: uploadFormData() llamado."); // LOG uploadFormData
            this.uiController.clearUploadMessages();
            if (!this.filesToUpload || this.filesToUpload.length === 0) {
                this.uiController.displayUploadMessage('No hay imágenes seleccionadas para subir.', 'warning');
                this.uiController.disableSubmitButton(); // Asegurar que el botón esté deshabilitado si no hay imágenes
                return;
            }

            if (this.isUploading) {
                console.log("Subida ya en progreso, abortando nueva subida.");
                return; // Evitar múltiples subidas simultáneas
            }
            this.isUploading = true;
            this.uiController.disableSubmitButton(); // Deshabilitar botón al iniciar subida


            const formData = new FormData(document.getElementById('image-upload-form'));
            for (let i = 0; i < this.filesToUpload.length; i++) {
                const fileData = this.filesToUpload[i];
                const compressedFile = new File([fileData.blob], fileData.originalName, {
                    type: 'image/jpeg'
                });
                formData.append('images[]', compressedFile);
            }

            this.uiController.displayUploadProgress(0);


            const uploadUrl = this.uploadUrl; // Asegúrate de que uploadUrl esté disponible aquí
            const progressCallback = (event) => {
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    this.uiController.displayUploadProgress(percentComplete);
                }
            };

            const responseCallback = (data) => {
                console.log("ImageUploadController: responseCallback() llamado con datos:", data); // LOG responseCallback
                this.uiController.hideUploadProgress();
                this.uiController.enableSubmitButton(); // Re-habilitar botón tras éxito
                // this.uiController.displayUploadMessage('Formulario e imágenes subidos correctamente.', 'success');
                this.uiController.displayFormResponses(data);
                this.uiController.clearPreviewArea();
                this.uiController.resetForm();
                this.filesToUpload = [];
                this.isUploading = false; // Resetear flag de subida
                if (this.filesToUpload.length === 0) {
                    this.uiController.disableSubmitButton(); // Deshabilitar si ya no hay archivos
                }
            };

            const errorCallback = (error) => {
                console.error("ImageUploadController: errorCallback() llamado con error:", error); // LOG errorCallback
                this.uiController.hideUploadProgress();
                this.uiController.enableSubmitButton(); // Re-habilitar botón tras error
                this.uiController.displayUploadMessage(`Error en la subida: ${error.message || 'Error desconocido.'}`, 'danger');
                this.uiController.displayFormResponses({
                    status: 'error',
                    message: error.message || 'Error de subida.'
                });
                this.isUploading = false; // Resetear flag de subida
            };


            this.uploader.upload(formData, uploadUrl, progressCallback, responseCallback, errorCallback);
            this.uiController.displayUploadProgress(100); // Simular progreso completo al iniciar
            this.uiController.progressBar.innerHTML = 'Subiendo...'; // Cambiar texto para indicar subida
        }
    }


    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOMContentLoaded: El DOM ha sido cargado."); // LOG DOMContentLoaded

        // Asegúrate de que 'AjaxHandler' y 'elemento' con 'data-valor-base-64' están definidos en tu contexto.
        // Este es un ejemplo y necesitarás adaptarlo a tu configuración específica.
        // Asegúrate de que 'AjaxHandler' y 'elemento' con 'data-valor-base-64' están definidos en tu contexto.
        // Este es un ejemplo y necesitarás adaptarlo a tu configuración específica.
        const elemento = document.getElementById('trash'); // Reemplaza 'trash' con el ID de tu elemento si es diferente
        const valorBase64 = elemento.getAttribute('data-valor-base64');
        // Asumiendo que AjaxHandler.decodificarBase64 es una función global accesible
        const url = typeof AjaxHandler !== 'undefined' && AjaxHandler.decodificarBase64 ? AjaxHandler.decodificarBase64(valorBase64) : '/api'; // Usar '/api' como fallback si AjaxHandler no está definido
        console.log("URL base decodificada:", url);



        const calidad = 0.5;
        const maxWidth = 2048;
        // Instanciar componentes
        const imageCompressor = new ImageCompressor(calidad, maxWidth); // Configuración de compresión: calidad 0.6, maxWidth 600
        const fileUploader = new FileUploader();
        const uiController = new UIController(
            'drop-area',
            'images',
            'image-preview',
            'upload-progress',
            '.progress-bar',
            'upload-message',
            'form-responses'
        );
        const imageUploadController = new ImageUploadController(imageCompressor, fileUploader, uiController, url + '/eventos/clientes/subir-imagenes');

        // Inicializar el controlador principal
        imageUploadController.initialize();
    });
</script>