class POSSystem {
  constructor(baseApiUrl) {
    // --- Estado de la Aplicación ---
    // this.baseApiUrl = baseApiUrl; // URL base de la API
    this.apiUrl = baseApiUrl; // URL base de tu API PHP (ej: '/api/v1/')
    this.currentTransaction = []; // Array de objetos: [{ product: {id, name, price, ...}, quantity: N }]
    this.selectedCustomer = null; // Objeto cliente: { id, name, phone, ...} o null
    this.selectedPaymentMethod = "cash"; // Método de pago activo ('cash', 'card', 'transfer', 'qr')
    this.products = []; // Array de objetos producto cargados de la API (o simulados)
    this.customers = []; // Array de objetos cliente cargados de la API (o simulados)
    this.productItems = document.querySelectorAll(".product-item");
    this.allProducts = []; // Array para almacenar todos los productos (simulados o cargados)
    this.generalResponses = document.getElementById("generalResponses");

    // Paso 1: Crear los elementos principales (los que no dependen de otros)
    this.elements = {
      // Navbar
      currentTime: document.getElementById("current-time"),

      // Sección Cliente
      customerSelectedArea: document.getElementById("customer-selected"),
      customerSearchArea: document.getElementById("customer-search-area"),
      customerSearchInput: document.getElementById("customer-search"),
      btnSearchCustomer: document.getElementById("btn-search-customer"),
      btnNewCustomer: document.getElementById("btn-new-customer"),
      btnChangeCustomer: document.getElementById("btn-change-customer"),

      // Modal Nuevo Cliente
      newCustomerModalElement: document.getElementById("newCustomerModal"),
      newCustomerForm: document.getElementById("new-customer-form"),
      newCustomerNameInput: document.getElementById("new-customer-name"),
      newCustomerPhoneInput: document.getElementById("new-customer-phone"),
      newCustomerEmailInput: document.getElementById("new-customer-email"),
      newCustomerAddressInput: document.getElementById("new-customer-address"),
      newCustomerTypeSelect: document.getElementById("new-customer-type"),
      btnSaveNewCustomer: document.getElementById("btn-save-new-customer"),

      // Sección Productos
      // productSearchInput: document.getElementById('product-search'),
      productCategoriesContainer: document.querySelector(".product-categories"),
      productListContainer: document.getElementById("product-list"),

      // Sección Carrito/Venta Actual
      emptyCartState: document.getElementById("empty-cart"),
      cartContentArea: document.getElementById("cart-content"),
      transactionItemsContainer: document.getElementById(
        "current-transaction-items"
      ),
      subtotalDisplay: document.querySelector(".subtotal-row span:last-child"),
      taxDisplay: document.querySelector(".tax-row span:last-child"),
      transactionTotalDisplay: document.getElementById("transaction-total"),
      paymentMethodsContainer: document.querySelector(".payment-methods"),

      // Botones de Acción
      btnCompleteSale: document.getElementById("btn-complete-sale"),
      // btnHoldSale: document.getElementById('btn-hold-sale'),
      btnCancelSale: document.getElementById("btn-cancel-sale"),

      // Modal Finalizar Venta
      completeSaleModalElement: document.getElementById("completeSaleModal"),
      completeSaleModalMethodDisplay: document.querySelector(
        "#completeSaleModal .form-control-plaintext i"
      ),
      completeSaleModalMethodTextDisplay: document.querySelector(
        "#completeSaleModal .form-control-plaintext"
      ),
      completeSaleModalTotalDisplay: document.querySelector(
        "#completeSaleModal .fs-5.fw-bold"
      ),
      completeSaleModalPaymentAmountInput:
        document.getElementById("payment-amount"),
      completeSaleModalChangeInput: document.getElementById("payment-change"),
      completeSaleModalSummaryTableBody: document.querySelector(
        "#completeSaleModal table tbody"
      ),
      completeSaleModalSummaryTableFoot: document.querySelector(
        "#completeSaleModal table tfoot"
      ),
      receiptPrintCheckbox: document.getElementById("receipt-print"),
      receiptEmailCheckbox: document.getElementById("receipt-email"),
      invoiceGenerateCheckbox: document.getElementById("invoice-generate"),
      btnConfirmSale: document.getElementById("btn-confirm-sale"),

      // Modal Búsqueda Rápida Producto
      quickSearchModalElement: document.getElementById("quickSearchModal"),
      quickSearchInput: document.getElementById("quick-search-input"),
      quickSearchResultsContainer: document
        .getElementById("quick-search-results")
        .querySelector(".list-group"),
    };

    // Paso 2: Crear los elementos que dependen de otros ya definidos
    this.elements.customerNameDisplay =
      this.elements.customerSelectedArea.querySelector(".customer-name");
    this.elements.customerDetailDisplay =
      this.elements.customerSelectedArea.querySelector(".customer-detail");

    // Inicializar modales de Bootstrap
    this.newCustomerModal = new bootstrap.Modal(
      this.elements.newCustomerModalElement
    );
    this.completeSaleModal = new bootstrap.Modal(
      this.elements.completeSaleModalElement
    );
    this.quickSearchModal = new bootstrap.Modal(
      this.elements.quickSearchModalElement
    );

    // --- Configuración y Datos (Simulados o para cargar de API) ---

    this.taxRate = 0.0; // Tasa de impuesto (ej: 16% para IVA en Colombia)
    // Categorías de productos simuladas (reemplazar por carga desde API)
    this.productCategories = ["Impresosor", "Digitales"];
  }

  // --- Inicialización ---
  init() {
    console.log("POSSystem: Inicializando...");
    this.initAllProductItems(); // Inicializar productos (reales)
    this.bindEvents(); // Configurar listeners de eventos
    this.updateTransactionDisplay(); // Actualizar la vista del carrito (inicialmente vacío)
    this.updateCustomerDisplay(); // Actualizar la vista del cliente (inicialmente sin seleccionar)
    this.updateTimeDisplay(); // Iniciar el reloj
    setInterval(this.updateTimeDisplay.bind(this), 60000); // Actualizar el reloj cada minuto
  }
  initAllProductItems() {
    this.productItems.forEach((item) => {
      const id = item.getAttribute("data-id");
      const name = item.getAttribute("data-name");
      const price = parseFloat(item.getAttribute("data-price"));

      // Extraer stock
      const stockElement = item.querySelector(".item-stock");
      let stock = 0;
      if (stockElement) {
        const stockText = stockElement.textContent.trim();
        if (stockText.toLowerCase() === "en stock") {
          stock = 1; // O podrías poner un valor por defecto diferente si "En stock" significa una cantidad desconocida pero positiva.
        } else {
          const stockMatch = stockText.match(/\d+/);
          if (stockMatch) {
            stock = parseInt(stockMatch[0], 10);
          }
        }
      }

      // Extraer categoría
      const categoryElement = item.querySelector(".product-category");
      const category = categoryElement
        ? categoryElement.textContent.trim()
        : "";

      // Extraer icono o imagen (prioriza i tag con clase fas)
      const iconElement = item.querySelector(".product-image i");
      const imageElement = item.querySelector(".product-image img");
      let icon = "";
      if (iconElement && iconElement.classList.length > 0) {
        icon = Array.from(iconElement.classList).join(" ");
      } else if (imageElement) {
        // Si hay una imagen y no un ícono font-awesome, podrías manejarlo aquí.
        // Por ahora, lo dejaremos vacío si no es un ícono FAS.
        // Si quisieras la URL de la imagen: icon = imageElement.getAttribute('src');
      }

      // Generar un SKU simple (puedes ajustar esta lógica)
      const sku = name
        ? name.substring(0, 3).toUpperCase() + "-" + id
        : "SKU-" + id;

      // Ajustar la categoría si es necesario según tu ejemplo de salida
      let adjustedCategory = category;
      if (category === "Impresiones") {
        adjustedCategory = "Impresos";
      } else if (category === "Electrónicos") {
        adjustedCategory = "Digitales";
      } else if (category === "Hogar") {
        adjustedCategory = "Impreses"; // Basado en tu ejemplo, aunque parece un typo por "Impresos" o "Digitales"
      } else if (category === "Ropa") {
        adjustedCategory = "Digitales";
      }

      this.allProducts.push({
        id: id,
        sku: sku,
        name: name,
        price: price,
        stock: stock,
        category: adjustedCategory,
        icon: icon,
      });
    });
  }

  // --- Manejo de Eventos ---
  bindEvents() {
    console.log("POSSystem: Configurando eventos...");

    // Evento para añadir producto (usando delegación en el grid)
    this.elements.productListContainer.addEventListener("click", (event) => {
      console.log("Clic en producto");
      const productItem = event.target.closest(".product-item");

      if (productItem) {
        console.log("POSSystem: todos los productos:", this.allProducts);
        // Encuentra el producto completo usando el ID del dataset
        const productId = productItem.dataset.id;
        const product = this.allProducts.find((p) => p.id === productId);
        if (product) {
          this.addProduct(product);
        }
      }
    });

    // Evento para buscar cliente
    this.elements.btnSearchCustomer.addEventListener("click", () =>
      this.searchCustomer()
    );
    // Permitir buscar cliente presionando Enter en el input
    this.elements.customerSearchInput.addEventListener("keypress", (event) => {
      if (event.key === "Enter") {
        event.preventDefault(); // Prevenir envío de formulario por defecto
        this.searchCustomer();
      }
    });

    // Evento para cambiar/remover cliente seleccionado
    this.elements.btnChangeCustomer.addEventListener("click", () =>
      this.resetCustomerSelection()
    );

    // Evento para guardar nuevo cliente (en el modal)
    this.elements.btnSaveNewCustomer.addEventListener("click", () =>
      this.saveNewCustomer()
    );

    // Eventos para selección de método de pago (usando delegación en el contenedor)
    this.elements.paymentMethodsContainer.addEventListener("click", (event) => {
      const paymentMethodElement = event.target.closest(".payment-method");
      if (paymentMethodElement) {
        const method = paymentMethodElement.dataset.method;
        this.selectPaymentMethod(method);
        console.log(`Método de pago seleccionado: ${method}`);
      }
    });

    // Evento para abrir modal de finalizar venta
    this.elements.btnCompleteSale.addEventListener("click", () =>
      this.openCompleteSaleModal()
    );

    // Evento para confirmar la venta (en el modal de finalizar venta)
    this.elements.btnConfirmSale.addEventListener("click", () =>
      this.completeSale()
    );

    // Evento para cancelar venta
    this.elements.btnCancelSale.addEventListener("click", () =>
      this.cancelSale()
    );
    // Eventos de cantidad y eliminar en items de transacción (usando delegación)
    this.elements.transactionItemsContainer.addEventListener(
      "click",
      (event) => {
        console.log("Clic en item de transacción");
        const target = event.target;
        const transactionItemElement = target.closest(".transaction-item");

        if (!transactionItemElement) return; // Salir si el clic no fue dentro de un item de transacción

        const itemId = transactionItemElement.dataset.id;

        // Manejar botones de cantidad
        if (target.classList.contains("quantity-btn")) {
          const action = target.dataset.action;
          this.updateQuantity(itemId, action === "increase" ? 1 : -1);
        }

        // Manejar botón de eliminar
        if (target.closest(".item-remove")) {
          // Usa closest para el icono o el span
          this.removeItem(itemId);
        }
      }
    );
    // Evento para calcular cambio en el modal de finalizar venta
    if (this.elements.completeSaleModalPaymentAmountInput) {
      this.elements.completeSaleModalPaymentAmountInput.addEventListener(
        "input",
        () => this.calculateChange()
      );
    }
    // Eventos del Modal Nuevo Cliente (limpiar formulario al cerrar)
    this.elements.newCustomerModalElement.addEventListener(
      "hidden.bs.modal",
      () => {
        this.elements.newCustomerForm.reset();
        // Opcional: resetear los mensajes de validación si existieran
      }
    );
    // Eventos del Modal Finalizar Venta (recalcular cambio si el total cambia, aunque aquí no cambia dinámicamente)
    this.elements.completeSaleModalElement.addEventListener(
      "show.bs.modal",
      () => {
        // Recalcular el cambio al abrir el modal por si el total ha cambiado
        this.calculateChange();
        // Populatear la tabla resumen en el modal
        this.renderCompleteSaleModalSummary();
      }
    );
    // Eventos del Modal Búsqueda Rápida Producto
    this.elements.quickSearchModalElement.addEventListener(
      "shown.bs.modal",
      () => {
        this.elements.quickSearchInput.focus(); // Enfocar el input al abrir
        this.elements.quickSearchInput.value = ""; // Limpiar búsqueda previa
        this.elements.quickSearchResultsContainer.innerHTML = ""; // Limpiar resultados previos
      }
    );
    this.elements.quickSearchInput.addEventListener("input", (event) => {
      const searchTerm = event.target.value.trim();
      // Si el término es lo suficientemente largo, hacer la búsqueda rápida
      if (searchTerm.length > 1) {
        // Define un umbral, ej: 2 caracteres
        this.quickSearchProducts(searchTerm);
      } else {
        this.elements.quickSearchResultsContainer.innerHTML = ""; // Limpiar si el término es muy corto
      }
    });
    // Evento para seleccionar un resultado de búsqueda rápida
    this.elements.quickSearchResultsContainer.addEventListener(
      "click",
      (event) => {
        const resultItem = event.target.closest(".list-group-item-action");
        if (resultItem) {
          event.preventDefault(); // Evitar navegación por defecto
          const productId = resultItem.dataset.id; // Asume que añades data-id al resultado

          const product = this.allProducts.find((p) => p.id === productId);
          if (product) {
            this.addProduct(product); // Añadir producto al carrito
            this.quickSearchModal.hide(); // Cerrar modal
          }
        }
      }
    );
    // Teclas de acceso rápido (ejemplo: Alt+B para búsqueda rápida)
    document.addEventListener("keydown", (e) => {
      // Alt+B para búsqueda rápida de productos
      if (e.altKey && e.key === "b") {
        e.preventDefault();
        this.quickSearchModal.show();
      }
      // Alt+P para abrir modal de completar venta
      if (e.altKey && e.key === "p") {
        e.preventDefault();
        this.openCompleteSaleModal(); // Llama al método que valida y abre el modal
      }
      // Alt+C para cancelar venta
      if (e.altKey && e.key === "c") {
        e.preventDefault();
        this.cancelSale();
      }
    });
  }

  // --- Métodos de Comunicación con la API (AJAX usando fetch y FormData) ---

  /**
   * Envía datos a la API usando POST con FormData.
   * @param {string} endpoint - La ruta del endpoint (ej: 'customers/search').
   * @param {string} method - El método HTTP ('POST').
   * @param {FormData} formData - Los datos a enviar.
   * @returns {Promise<object>} - La respuesta de la API en formato JSON.
   * @throws {Error} - Si la respuesta de la red no es OK o si ocurre un error.
   */
  async fetchData(endpoint, method, formData) {
    const url = `${this.apiUrl}${endpoint}`;
    console.log(`POSSystem: Realizando POST a ${url}`);

    try {
      const response = await fetch(url, {
        method: "POST", // Forzamos POST según el requisito
        body: formData, // FormData es compatible con POST
        // No necesitamos 'Content-Type' para FormData; el navegador lo establece correctamente.
      });

      // Verificar si la respuesta HTTP fue exitosa (status 200-299)
      if (!response.ok) {
        const errorBody = await response.text(); // Intentar leer como texto para debug
        console.error(
          `POSSystem: Error HTTP ${response.status} en ${url}`,
          errorBody
        );
        throw new Error(
          `Error de red: ${response.status} ${response.statusText}`
        );
      }

      // Parsear la respuesta JSON
      const data = await response.json();
      console.log(`POSSystem: Respuesta de ${url}`, data);

      // Opcional: Verificar una propiedad 'success' en la respuesta JSON si tu API la usa
      // if (data && data.success === false) {
      //     console.error(`POSSystem: Error de API en ${url}`, data.message || 'Error desconocido');
      //     throw new Error(`Error de API: ${data.message || 'Error desconocido'}`);
      // }

      return data;
    } catch (error) {
      console.error(
        `POSSystem: Error al comunicarse con la API en ${url}`,
        error
      );
      // Re-lanzar el error para que pueda ser manejado por quien llamó a fetchData
      throw error;
    }
  }
  // --- Métodos de Lógica de Negocio ---
  /**
   * Busca un cliente en la API.
   */
  async searchCustomer() {
    const searchTerm = this.elements.customerSearchInput.value.trim();
    if (!searchTerm) {
      this.selectedCustomer = null;
      this.updateCustomerDisplay(
        "alert-info",
        "Por favor, busca o registra un cliente."
      );
      return;
    }

    const formData = new FormData();
    formData.append("searchTerm", searchTerm);

    const myAjax = new ModernAjaxHandler({
      // timeout: 1000, // Timeout global de 10 segundos (opcional)
    });
    myAjax
      .post(this.apiUrl + "/customers/search", formData, {
        headers: {
          // No es necesario configurar 'Content-Type' para FormData, el navegador lo hace automáticamente
        },
      })
      .then((response) => {
        console.log("Respuesta de la API:", response);
        // let responseDivs = document.querySelectorAll(".formResponses");
        if (typeof response === "object") {
          if (response.success) {
            this.generalResponses.innerHTML = "";
            const alert = BootstrapAlertFactory.createAlert({
              message: response.message,
              type: "success",
              dismissible: true,
              icon: "far fa-check-circle",
            });
            this.generalResponses.appendChild(alert.generateAlert());
            this.selectCustomer(response.customer);
            this.updateCustomerDisplay("alert-success", ""); // El display se actualiza con los datos del cliente
          } else {
            this.generalResponses.innerHTML = "";
            const alert = BootstrapAlertFactory.createAlert({
              message: response.message,
              type: "warning",
              dismissible: true,
              icon: "fas fa-exclamation-triangle",
            });
            this.generalResponses.appendChild(alert.generateAlert());
          }
        } else {
          const alert = BootstrapAlertFactory.createAlert({
            message: response,
            type: "warning",
            dismissible: true,
            icon: "fas fa-exclamation-triangle",
          });
          this.generalResponses.innerHTML = "";
          this.generalResponses.appendChild(alert.generateAlert());
        }
      })
      .catch((error) => {
        // console.error("Error: ", error);
        const alert = BootstrapAlertFactory.createAlert({
          message:
            "Error general, intentelo de nuevo, si el problema persiste contacte al administrador",
          type: "danger",
          dismissible: true,
          icon: "fas fa-exclamation-triangle",
        });
        this.generalResponses.innerHTML = "";
        this.generalResponses.appendChild(alert.generateAlert());
      });
  }
  /**
   * Selecciona un cliente y actualiza la vista.
   * @param {object} customerData - El objeto del cliente seleccionado.
   */
  selectCustomer(customerData) {
    this.selectedCustomer = customerData;
    this.updateCustomerDisplay("alert-success", ""); // El display se actualiza con los datos del cliente
    console.log("POSSystem: Cliente seleccionado", customerData);
    // Ocultar área de búsqueda y mostrar área de cliente seleccionado
    this.elements.customerSearchArea.style.display = "none";
    this.elements.customerSelectedArea.style.display = "flex"; // Usar flex para el badge
  }
  /**
   * Restablece la selección de cliente a su estado inicial.
   */
  resetCustomerSelection() {
    this.selectedCustomer = null;
    this.elements.customerSearchInput.value = ""; // Limpiar input de búsqueda
    this.updateCustomerDisplay(
      "alert-info",
      "Por favor, busca o registra un cliente."
    );
    // Mostrar área de búsqueda y ocultar área de cliente seleccionado
    this.elements.customerSelectedArea.style.display = "none";
    this.elements.customerSearchArea.style.display = "block";
    console.log("POSSystem: Selección de cliente restablecida.");
  }
  /**
   * Guarda un nuevo cliente llamando a la API.
   */
  async saveNewCustomer() {
    const form = document.getElementById("new-customer-form");
    const validator = new FieldValidator(form);
    const isValid = validator.validateForm();
    if (isValid) {
      const formDataExtractor = new FormDataExtractor(form, {
        excludedFields: [], // Opcional: campos a excluir
      });
      const formData = formDataExtractor.extract();
      console.log("POSSystem: NewCustomerFor data: ", formData);
      const myAjax = new ModernAjaxHandler({
        // timeout: 1000, // Timeout global de 10 segundos (opcional)
      });
      myAjax
        .post(this.apiUrl + "/customers/new", formData, {
          headers: {
            // No es necesario configurar 'Content-Type' para FormData, el navegador lo hace automáticamente
          },
        })
        .then((response) => {
          console.log("Respuesta de la API:", response);
          if (typeof response === "object") {
            if (response.success) {
              this.generalResponses.innerHTML = "";
              const alert = BootstrapAlertFactory.createAlert({
                message: response.message,
                type: "success",
                dismissible: true,
                icon: "far fa-check-circle",
              });
              this.generalResponses.appendChild(alert.generateAlert());

              this.selectCustomer(response.customer); // Seleccionar el cliente recién creado
              this.updateCustomerDisplay(
                "alert-success",
                `Nuevo cliente registrado y seleccionado: ${response.customer.name}`
              ); // Mensaje de éxito
              this.newCustomerModal.hide(); // Cerrar el modal
              this.elements.newCustomerForm.reset(); // Limpiar el formulario del modal
              this.elements.customerSearchInput.value = ""; // Limpiar el campo de búsq
              validator.clearErrors();
            } else {
              this.generalResponses.innerHTML = "";
              const alert = BootstrapAlertFactory.createAlert({
                message: response.message,
                type: "warning",
                dismissible: true,
                icon: "fas fa-exclamation-triangle",
              });
              this.generalResponses.appendChild(alert.generateAlert());
              this.newCustomerModal.hide(); // Cerrar el modal
              this.elements.newCustomerForm.reset(); // Limpiar el formulario del modal
              this.elements.customerSearchInput.value = ""; // Limpiar el campo de búsq
              validator.clearErrors();
            }
          } else {
            const alert = BootstrapAlertFactory.createAlert({
              message: response,
              type: "warning",
              dismissible: true,
              icon: "fas fa-exclamation-triangle",
            });
            this.generalResponses.innerHTML = "";
            this.generalResponses.appendChild(alert.generateAlert());
          }
        })
        .catch((error) => {
          console.error("Error: ", error);
        });
    }
  }

  /**
   * Actualiza la visualización del área de cliente.
   * @param {string} alertClass - Clase de alerta de Bootstrap (ej: 'alert-info', 'alert-success').
   * @param {string} message - Mensaje a mostrar si no hay cliente seleccionado.
   */
  updateCustomerDisplay(alertClass = "alert-info", message = "") {
    console.log("POSSystem: Actualizando visualización de cliente...");
    const customerDisplay = this.elements.customerSelectedArea; // Ahora usamos el área del badge
    const customerSearchArea = this.elements.customerSearchArea;

    // Remover clases de alerta anteriores del área del badge (aunque el badge en sí no es una alerta)
    // Si el mensaje se muestra en el área de búsqueda, aplicar clases de alerta a esa área.
    // El HTML usa un div aparte (#customer-display) para mensajes antes del row de búsqueda
    const initialCustomerDisplay = document.getElementById("customer-display"); // El div original que tenía el mensaje
    console.log(initialCustomerDisplay);

    // Lógica para mostrar el badge o el área de búsqueda
    if (this.selectedCustomer) {
      this.elements.customerNameDisplay.textContent =
        this.selectedCustomer.name;
      // Combina teléfono y email si existen
      let details = [];
      if (this.selectedCustomer.phone)
        details.push(`Tel: ${this.selectedCustomer.phone}`);
      if (this.selectedCustomer.email)
        details.push(this.selectedCustomer.email);
      this.elements.customerDetailDisplay.textContent = details.join(" | ");
      // Opcional: Actualizar el badge de tipo de cliente si tu API lo devuelve y tu HTML tiene el span
      const typeBadge = customerDisplay.querySelector(".badge");
      if (typeBadge && this.selectedCustomer.type) {
        typeBadge.textContent = this.selectedCustomer.type;
        // Puedes cambiar la clase de color del badge basado en el tipo si quieres
        typeBadge.classList.remove("bg-success", "bg-info", "bg-secondary"); // Remover clases anteriores
        if (this.selectedCustomer.type === "VIP")
          typeBadge.classList.add("bg-info");
        else if (this.selectedCustomer.type === "Mayorista")
          typeBadge.classList.add("bg-secondary");
        else typeBadge.classList.add("bg-success"); // Por defecto Regular
        typeBadge.style.display = "inline-block"; // Asegurar que se muestre si está oculto
      } else if (typeBadge) {
        typeBadge.style.display = "none"; // Ocultar si no hay tipo o badge
      }
      customerSearchArea.style.display = "none"; // Ocultar la búsqueda
      customerDisplay.style.display = "flex"; // Mostrar el badge
      // initialCustomerDisplay.style.display = 'none'; // Ocultar el mensaje inicial
    } else {
      console.log("POSSystem: No hay cliente seleccionado.");
      customerSearchArea.style.display = "block"; // Mostrar la búsqueda
      customerDisplay.style.display = "none"; // Ocultar el badge
      // initialCustomerDisplay.style.display = 'block'; // Mostrar el mensaje inicial

      // Actualizar el mensaje y la clase de alerta en el div de mensaje inicial
      initialCustomerDisplay.textContent = message;
      initialCustomerDisplay.classList.remove(
        "alert-info",
        "alert-success",
        "alert-warning",
        "alert-danger"
      );
      initialCustomerDisplay.classList.add("alert", alertClass);
    }
  }
  /**
   * Renderiza la lista de categorías de productos.
   */
  renderCategories() {
    const container = this.elements.productCategoriesContainer;
    container.innerHTML = ""; // Limpiar lista actual

    this.productCategories.forEach((category) => {
      const categoryElement = document.createElement("div");
      categoryElement.classList.add("category-pill");
      if (category === "Todos") {
        categoryElement.classList.add("active"); // Marcar "Todos" como activo por defecto
      }
      categoryElement.textContent = category;
      container.appendChild(categoryElement);
    });
    // Los eventos se binden en init() usando delegación
  }
  /**
   * Filtra los productos mostrados por categoría.
   * @param {string|null} category - La categoría por la cual filtrar, o null para mostrar todos.
   */
  filterProductsByCategory(category) {
    let filteredProducts = this.allProducts;
    if (category) {
      filteredProducts = this.allProducts.filter(
        (product) => product.category === category
      );
    }
    this.renderProducts(filteredProducts);
  }

  /**
   * Busca productos localmente por término de búsqueda (nombre, sku).
   * @param {string} searchTerm - El término de búsqueda.
   */
  searchProducts(searchTerm) {
    const lowerSearchTerm = searchTerm.toLowerCase();
    const filteredProducts = this.allProducts.filter(
      (product) =>
        product.name.toLowerCase().includes(lowerSearchTerm) ||
        (product.sku && product.sku.toLowerCase().includes(lowerSearchTerm)) // Buscar por SKU si existe
    );
    this.renderProducts(filteredProducts);
  }

  /**
   * Realiza una búsqueda rápida de productos (usado en el modal).
   * Esta podría hacer una llamada a la API diferente si la lista de productos es muy grande.
   * @param {string} searchTerm - El término de búsqueda.
   */
  async quickSearchProducts(searchTerm) {
    // Para <10 productos, la búsqueda local es suficiente.
    // Si tuvieras muchos productos, aquí harías una llamada AJAX a la API:
    // const formData = new FormData();
    // formData.append('searchTerm', searchTerm);
    // const results = await this.fetchData('products/quicksearch', 'POST', formData);
    // const products = results.products || []; // Asume la API devuelve { success: true, products: [...] }

    // SIMULACIÓN de búsqueda rápida local
    const lowerSearchTerm = searchTerm.toLowerCase();
    const products = this.allProducts
      .filter(
        (product) =>
          product.name.toLowerCase().includes(lowerSearchTerm) ||
          (product.sku && product.sku.toLowerCase().includes(lowerSearchTerm))
      )
      .slice(0, 10); // Limita los resultados mostrados

    const container = this.elements.quickSearchResultsContainer;
    container.innerHTML = ""; // Limpiar resultados previos

    if (products.length === 0) {
      container.innerHTML =
        '<div class="list-group-item text-muted">No se encontraron resultados.</div>';
    } else {
      products.forEach((product) => {
        const resultItem = document.createElement("a");
        resultItem.href = "#"; // Evitar navegación
        resultItem.classList.add("list-group-item", "list-group-item-action");
        resultItem.dataset.id = product.id; // Añadir ID para poder añadir al carrito
        resultItem.innerHTML = `
                      <div class="d-flex w-100 justify-content-between">
                         <h6 class="mb-1">${product.name}</h6>
                         <span class="text-primary fw-bold">$${product.price.toFixed(
                           2
                         )}</span>
                     </div>
                     <p class="mb-1 small text-muted">SKU: ${
                       product.sku || "N/A"
                     } | Stock: ${
          product.stock !== undefined ? product.stock : "N/A"
        }</p>
                 `;
        container.appendChild(resultItem);
      });
    }
    // El evento de click para seleccionar un resultado se maneja en bindEvents usando delegación.
  }

  /**
   * Añade un producto al carrito o incrementa su cantidad.
   * @param {object} product - El objeto producto a añadir.
   */
  addProduct(product) {
    console.log("POSSystem: Añadiendo producto al carrito", product);
    const existingItem = this.currentTransaction.find(
      (item) => item.product.id === product.id
    );

    if (existingItem) {
      existingItem.quantity++;
    } else {
      // Almacena el objeto completo del producto y la cantidad
      this.currentTransaction.push({
        product: product,
        quantity: 1,
      });
    }

    this.updateTransactionDisplay(); // Actualizar la vista del carrito
    console.log(
      `POSSystem: Añadido "${product.name}" al carrito. Cantidad actual: ${
        existingItem ? existingItem.quantity : 1
      }`
    );
  }

  /**
   * Actualiza la cantidad de un producto en el carrito.
   * @param {string} productId - ID del producto.
   * @param {number} delta - Cantidad a sumar o restar (1 o -1).
   */
  updateQuantity(productId, delta) {
    const itemIndex = this.currentTransaction.findIndex(
      (item) => item.product.id === productId
    );

    if (itemIndex > -1) {
      this.currentTransaction[itemIndex].quantity += delta;

      // Si la cantidad es <= 0, eliminar el item
      if (this.currentTransaction[itemIndex].quantity <= 0) {
        this.removeItem(productId); // Llama al método de remover
      } else {
        this.updateTransactionDisplay(); // Solo actualizar si la cantidad es > 0
      }
      console.log(
        `POSSystem: Cantidad de "${
          this.currentTransaction[itemIndex]?.product.name || productId
        }" actualizada a ${this.currentTransaction[itemIndex]?.quantity || 0}.`
      );
    }
  }

  /**
   * Elimina un producto del carrito.
   * @param {string} productId - ID del producto a eliminar.
   */
  removeItem(productId) {
    const initialLength = this.currentTransaction.length;
    this.currentTransaction = this.currentTransaction.filter(
      (item) => item.product.id !== productId
    );

    if (this.currentTransaction.length < initialLength) {
      this.updateTransactionDisplay(); // Solo actualizar si se eliminó algo
      console.log(
        `POSSystem: Producto con ID "${productId}" eliminado del carrito.`
      );
    }
  }

  /**
   * Calcula el subtotal, impuestos y total de la transacción.
   * @returns {{subtotal: number, tax: number, total: number}} Los totales calculados.
   */
  calculateTotals() {
    const subtotal = this.currentTransaction.reduce(
      (sum, item) => sum + item.product.price * item.quantity,
      0
    );
    const tax = subtotal * this.taxRate;
    const total = subtotal + tax;
    return {
      subtotal,
      tax,
      total,
    };
  }

  /**
   * Selecciona el método de pago y actualiza la UI.
   * @param {string} method - El método seleccionado ('cash', 'card', etc.).
   */
  selectPaymentMethod(method) {
    this.selectedPaymentMethod = method;
    // Actualiza visualmente los botones de método de pago
    this.elements.paymentMethodsContainer
      .querySelectorAll(".payment-method")
      .forEach((element) => {
        if (element.dataset.method === method) {
          element.classList.add("active");
        } else {
          element.classList.remove("active");
        }
      });
    // Opcional: Mostrar campos adicionales en la UI según el método de pago (ej: número de tarjeta)
  }

  getTotal() {
    const totals = this.calculateTotals();
    return totals.total; // Devuelve el total calculado
  }

  /**
   * Calcula el cambio en el modal de finalizar venta.
   */
  calculateChange() {
    const total = this.getTotal(); // Usa el total calculado del carrito
    const paymentAmountInput =
      this.elements.completeSaleModalPaymentAmountInput;
    const changeInput = this.elements.completeSaleModalChangeInput;

    const paymentAmount = parseFloat(paymentAmountInput.value) || 0;
    const change = Math.max(0, paymentAmount - total).toFixed(2); // Asegura que el cambio no sea negativo
    changeInput.value = change;
  }

  /**
   * Prepara y abre el modal para finalizar la venta.
   */
  openCompleteSaleModal() {
    // Validar que haya un cliente seleccionado
    if (!this.selectedCustomer) {
      alert(
        "Debes seleccionar o registrar un cliente antes de completar la venta."
      );
      // Opcional: Resaltar el área de cliente
      this.elements.customerSearchInput.focus();
      return;
    }
    // Validar que haya productos en el carrito
    if (this.currentTransaction.length === 0) {
      alert("Agrega productos a la venta antes de completarla.");
      // Opcional: Resaltar el área de productos
      this.elements.productListContainer.scrollIntoView({
        behavior: "smooth",
      });
      return;
    }

    const total = this.getTotal(); // Calcula el total más reciente

    // Actualizar detalles en el modal
    const methodElement = this.elements.paymentMethodsContainer.querySelector(
      ".payment-method.active"
    );
    const methodText = methodElement
      ? methodElement.querySelector("span").textContent
      : "Desconocido";
    const methodIconClass = methodElement
      ? methodElement.querySelector("i").className
      : "fas fa-question-circle";

    // Actualiza el display del método y total en el modal
    this.elements.completeSaleModalMethodDisplay.className =
      methodIconClass + " me-2"; // Asegura el espacio
    this.elements.completeSaleModalMethodTextDisplay.textContent = methodText; // Actualiza solo el texto
    this.elements.completeSaleModalTotalDisplay.textContent = `$${total.toFixed(
      2
    )}`;

    // Restablecer y calcular cambio inicial (basado en el total, input de pago podría tener un valor por defecto)
    this.elements.completeSaleModalPaymentAmountInput.value = total.toFixed(2); // Por defecto, monto recibido = total
    this.calculateChange(); // Calcular cambio basado en el valor inicial

    // Renderizar el resumen de la transacción en la tabla del modal
    this.renderCompleteSaleModalSummary();

    // Mostrar el modal
    this.completeSaleModal.show();
    console.log("POSSystem: Abriendo modal de finalizar venta.");
  }

  /**
   * Renderiza la tabla de resumen en el modal de finalizar venta.
   */
  renderCompleteSaleModalSummary() {
    const tbody = this.elements.completeSaleModalSummaryTableBody;
    const tfoot = this.elements.completeSaleModalSummaryTableFoot;
    tbody.innerHTML = ""; // Limpiar cuerpo de la tabla

    this.currentTransaction.forEach((item) => {
      const row = document.createElement("tr");
      row.innerHTML = `
                 <td>${item.product.name}</td>
                 <td class="text-center">${item.quantity}</td>
                 <td class="text-end">$${item.product.price.toFixed(2)}</td>
                 <td class="text-end">$${(
                   item.product.price * item.quantity
                 ).toFixed(2)}</td>
             `;
      tbody.appendChild(row);
    });

    // Actualizar el pie de página de la tabla de resumen (subtotal, IVA, total)
    const totals = this.calculateTotals();
    tfoot.innerHTML = `
             <tr>
                 <th colspan="3" class="text-end">Subtotal:</th>
                 <th class="text-end">$${totals.subtotal.toFixed(2)}</th>
             </tr>
             <tr>
                 <th colspan="3" class="text-end">IVA (${(
                   this.taxRate * 100
                 ).toFixed(0)}%):</th>
                 <th class="text-end">$${totals.tax.toFixed(2)}</th>
             </tr>
             <tr>
                 <th colspan="3" class="text-end">Total:</th>
                 <th class="text-end text-success">$${totals.total.toFixed(
                   2
                 )}</th>
             </tr>
         `;
  }

  /**
   * Procesa la venta llamando a la API.
   */
  async completeSale() {
    // Validaciones ya se hicieron al abrir el modal, pero es buena práctica repetir algunas
    if (!this.selectedCustomer || this.currentTransaction.length === 0) {
      alert("Error: Cliente o productos faltantes.");
      this.completeSaleModal.hide(); // Cerrar el modal si hay un error de estado
      return;
    }

    const total = this.getTotal();
    const paymentAmount =
      parseFloat(this.elements.completeSaleModalPaymentAmountInput.value) || 0;
    const paymentMethod = this.selectedPaymentMethod; // Método seleccionado globalmente

    if (paymentMethod === "cash" && paymentAmount < total) {
      alert("El monto recibido es menor que el total.");
      this.elements.completeSaleModalPaymentAmountInput.focus();
      return;
    }
    // Añadir validaciones para otros métodos si es necesario (ej: número de tarjeta)

    // Crear FormData para enviar al backend PHP
    const formData = new FormData();

    this.currentTransaction.forEach((item, index) => {
      formData.append(`items[${index}][id]`, item.product.id);
      formData.append(`items[${index}][quantity]`, item.quantity);
      formData.append(`items[${index}][price]`, item.product.price.toFixed(2));
    });
    const event_id = document.getElementById("my_event").value;
    const vendedor_id = document.getElementById("sales_person_id").value;

    formData.append("event_id", event_id);
    formData.append("user_id", this.selectedCustomer.id);
    formData.append("vendedor_id", vendedor_id);
    formData.append("total", total.toFixed(2));
    formData.append("payment_method", paymentMethod);
    formData.append("amount_received", paymentAmount.toFixed(2)); // Monto recibido
    formData.append(
      "change_given",
      Math.max(0, paymentAmount - total).toFixed(2)
    ); // Cambio dado
    formData.append(
      "print_receipt",
      this.elements.receiptPrintCheckbox.checked ? "1" : "0"
    );
    formData.append(
      "email_receipt",
      this.elements.receiptEmailCheckbox.checked ? "1" : "0"
    );
    formData.append(
      "generate_invoice",
      this.elements.invoiceGenerateCheckbox.checked ? "1" : "0"
    );

    const myAjax = new ModernAjaxHandler({
      // timeout: 1000, // Timeout global de 10 segundos (opcional)
    });
    myAjax
      .post(this.apiUrl + "/sales/process", formData, {
        headers: {
          // No es necesario configurar 'Content-Type' para FormData, el navegador lo hace automáticamente
        },
      })
      .then((response) => {
        console.log("Respuesta de la API:", response);
        // let responseDivs = document.querySelectorAll(".formResponses");
        if (typeof response === "object") {
          if (response.success) {
            this.generalResponses.innerHTML = "";
            const alert = BootstrapAlertFactory.createAlert({
              message: response.message,
              type: "success",
              dismissible: true,
              icon: "far fa-check-circle",
            });
            this.generalResponses.appendChild(alert.generateAlert());
            this.completeSaleModal.hide();
            this.resetPOS();
          } else {
            this.generalResponses.innerHTML = "";
            const alert = BootstrapAlertFactory.createAlert({
              message: response.message,
              type: "warning",
              dismissible: true,
              icon: "fas fa-exclamation-triangle",
            });
            this.generalResponses.appendChild(alert.generateAlert());
            this.completeSaleModal.hide();
          }
        } else {
          const alert = BootstrapAlertFactory.createAlert({
            message: response,
            type: "warning",
            dismissible: true,
            icon: "fas fa-exclamation-triangle",
          });
          this.generalResponses.innerHTML = "";
          this.generalResponses.appendChild(alert.generateAlert());
          this.completeSaleModal.hide();
          this.resetPOS();
        }
      })
      .catch((error) => {
        // console.error("Error: ", error);
        const alert = BootstrapAlertFactory.createAlert({
          message:
            "Error general, intentelo de nuevo, si el problema persiste contacte al administrador",
          type: "danger",
          dismissible: true,
          icon: "fas fa-exclamation-triangle",
        });
        this.generalResponses.innerHTML = "";
        this.generalResponses.appendChild(alert.generateAlert());
      });
  }
  /**
   * Cancela la venta actual tras confirmación.
   */
  cancelSale() {
    if (this.currentTransaction.length > 0 || this.selectedCustomer) {
      if (
        confirm(
          "¿Estás seguro de que deseas cancelar la venta actual? Se perderán los productos y el cliente asociado."
        )
      ) {
        this.resetPOS();
        // alert("Venta cancelada.");
        console.log("POSSystem: Venta cancelada por el usuario.");
      }
    } else {
      alert("No hay una venta en curso para cancelar.");
    }
  }

  /**
   * Reinicia el estado del sistema POS para una nueva venta.
   */
  resetPOS() {
    this.currentTransaction = [];
    this.selectedCustomer = null;
    this.selectedPaymentMethod = "cash"; // Restablecer método de pago por defecto

    // Limpiar campos e inputs
    this.elements.customerSearchInput.value = "";
    // Restablecer botones de método de pago (seleccionar el primero/efectivo)
    this.elements.paymentMethodsContainer
      .querySelectorAll(".payment-method")
      .forEach((element, index) => {
        element.classList.remove("active");
        if (index === 0) element.classList.add("active");
      });

    // Actualizar las vistas
    this.updateTransactionDisplay(); // Vaciar carrito
    this.updateCustomerDisplay(
      "alert-info",
      "Por favor, busca o registra un cliente."
    ); // Resetear vista de cliente
    // this.renderProducts(this.allProducts); // Mostrar todos los productos de nuevo
    console.log("POSSystem: Sistema POS reiniciado.");
  }

  // --- Métodos de Renderizado/Actualización de UI ---

  /**
   * Actualiza la visualización de la lista de items en el carrito y los totales.
   */
  updateTransactionDisplay() {
    const itemsContainer = this.elements.transactionItemsContainer;
    const emptyState = this.elements.emptyCartState;
    const cartContent = this.elements.cartContentArea;

    itemsContainer.innerHTML = ""; // Limpiar lista actual

    if (this.currentTransaction.length === 0) {
      emptyState.style.display = "block";
      cartContent.style.display = "none";
    } else {
      emptyState.style.display = "none";
      cartContent.style.display = "block";

      this.currentTransaction.forEach((item) => {
        const itemElement = document.createElement("div");
        itemElement.classList.add("transaction-item");
        // Almacena el ID del producto en el dataset para poder manipularlo
        itemElement.dataset.id = item.product.id;
        itemElement.innerHTML = `
                    <div class="item-details">
                        <div class="item-name">${item.product.name}</div>
                        <div class="item-actions">
                            <div class="quantity-control">
                                <button class="btn btn-sm btn-outline-secondary quantity-btn" data-action="decrease">-</button>
                                <span class="quantity">${item.quantity}</span>
                                <button class="btn btn-sm btn-outline-secondary quantity-btn" data-action="increase">+</button>
                            </div>
                            <span class="item-remove" title="Eliminar"><i class="fas fa-trash-alt"></i></span>
                        </div>
                    </div>
                    <div class="item-price">$${(
                      item.product.price * item.quantity
                    ).toFixed(2)}</div>
                `;
        itemsContainer.appendChild(itemElement);
      });
    }

    // Siempre actualizar los totales, incluso si el carrito está vacío
    this.updateTotalsDisplay();
  }

  /**
   * Actualiza la visualización de los subtotales, impuestos y total final.
   */
  updateTotalsDisplay() {
    const totals = this.calculateTotals();
    console.log("POSSystem: Totales actualizados", totals);
    // Actualiza los spans correspondientes en la sección de totales
    // Nota: Los spans de subtotal e IVA en tu HTML tienen selectores más específicos
    this.elements.subtotalDisplay.textContent = `$${totals.subtotal.toFixed(
      2
    )}`;
    this.elements.taxDisplay.textContent = `$${totals.tax.toFixed(2)}`; // Asegúrate de tener la tasa de impuesto correcta
    this.elements.transactionTotalDisplay.textContent = totals.total.toFixed(2); // El span ya tiene el "$" en el HTML
  }

  /**
   * Actualiza el display de la hora actual en la navbar.
   */
  updateTimeDisplay() {
    const now = new Date();
    const timeString = now.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
    });
    if (this.elements.currentTime) {
      this.elements.currentTime.textContent = timeString;
    }
  }
}
document.addEventListener("DOMContentLoaded", function () {
  const decoder = new Base64Decoder("trash");
  let baseApiUrl = decoder.decode();
  console.log(baseApiUrl);
  const posSystem = new POSSystem(baseApiUrl);
  posSystem.init();
  console.log("Sistema POS completamente inicializado con JS OO.");
});
